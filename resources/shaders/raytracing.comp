#version 430 core

struct IntersectionData {
    bool hit;
    vec3 position;
    vec3 tris[3];
};

struct Model {
    vec4 vertexData[1024];
    mat4 modelMatrix;
    vec4 numTris;
};

struct Light {
    vec4 position;
    vec4 color;
};

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;
layout(std430, binding = 1) buffer shaderDataBuffer {
    Model models[4];
    Light lights[4];
    vec4 cameraPosition;
    int numLights;
    int numModels;
};

vec3 raytrace(vec3 origin, vec3 rayDir);

IntersectionData rayCastTriangles(vec3 origin, vec3 rayDir);

void main() {
    vec4 pixelColor = vec4(1.0, 0.0, 0.0, 1.0);

    //Constants and definitions
    const float pi = 3.14159f;

    //Computing ray direction
    float invWidth = 1 / float(imageWidth), invHeight = 1 / float(imageHeight);
    float fov = 30;
    float aspectratio = imageWidth / float(imageHeight);
    float angle = tan(pi * 0.5 * fov / 180.0f);
    float xx = (2 * ((gl_GlobalInvocationID.x + 0.5) * invWidth) - 1) * angle * aspectratio;
    float yy = -(1 - 2 * ((gl_GlobalInvocationID.y + 0.5) * invHeight)) * angle;  //Y-Axis is flipped
    vec3 rayDir = vec3(xx, yy, 1);
    rayDir = normalize(rayDir);

    pixelColor.xyz = raytrace(cameraPosition.xyz, rayDir);
    //pixelColor = pixelColor * 0.1f;
    pixelColor.xyz = pixelColor.xyz / 255.0f;
    //pixelColor.w = 1.0f;
    //pixelColor.xyz = models[1].vertexData[35].xyz;

    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    imageStore(img_output, pixel_coords, pixelColor);
}

vec3 raytrace(vec3 origin, vec3 rayDir) {
    const float pi = 3.14159f;
    IntersectionData intersect = rayCastTriangles(origin, rayDir);

    if (intersect.hit) {
        vec3 diffuseColor = vec3(0, 0, 0);
        vec3 albedo = vec3(255, 255, 0);
        int lightHits = 0;
        for (int i = 0; i < numLights; i++) {
            float diffuseModifier = 1.0f;

            float dst = distance(intersect.position, lights[i].position.xyz);
            vec3 shadowRayDir = lights[i].position.xyz - intersect.position;
            shadowRayDir = normalize(shadowRayDir);
            vec3 norm = cross(intersect.tris[0] - intersect.tris[1], intersect.tris[0] - intersect.tris[2]);
            norm = normalize(norm);
            float angleModifier = clamp((acos(dot(norm, shadowRayDir)) * 180.0f / pi / 360.0f), 0.0f, 1.0f);
            diffuseModifier = diffuseModifier / (1 + pow(dst / (100.0f * lights[i].color.a * angleModifier), 2.0f));

            IntersectionData shadowIntersect = rayCastTriangles(intersect.position, shadowRayDir);
            if (!shadowIntersect.hit) {
                vec3 lightColor = lights[i].color.xyz;
                vec3 singleLightPixelColor = vec3(clamp(albedo.r * (1 - diffuseModifier) + lightColor.r * (1 - diffuseModifier) * 0.3f, 0.0f, 255.0f),
                                                  clamp(albedo.g * (1 - diffuseModifier) + lightColor.g * (1 - diffuseModifier) * 0.3f, 0.0f, 255.0f),
                                                  clamp(albedo.b * (1 - diffuseModifier) + lightColor.b * (1 - diffuseModifier) * 0.3f, 0.0f, 255.0f));
                diffuseColor = vec3(clamp(diffuseColor.r + singleLightPixelColor.r * (1.0f / numLights), 0.0f, 255.0f),
                                    clamp(diffuseColor.g + singleLightPixelColor.g * (1.0f / numLights), 0.0f, 255.0f),
                                    clamp(diffuseColor.b + singleLightPixelColor.b * (1.0f / numLights), 0.0f, 255.0f));
                lightHits++;
            }
        }
        if (lightHits > 0) {
            return diffuseColor;
        } else {
            vec3 nullVec = vec3(0, 0, 0);
            return nullVec;
        }
    } else {
        vec3 nullVec = vec3(0, 0, 0);
        return nullVec;
    }
}

IntersectionData rayCastTriangles(vec3 origin, vec3 rayDir) {
    IntersectionData closestIntersect;
    closestIntersect.hit = false;
    closestIntersect.position = vec3(0, 0, 0);
    float dst = 9999999.0f;

    for (int m = 0; m < numModels; m++) {
        for (int i = 0; i < models[m].numTris.x * 3; i += 3) {
            //Möller–Trumbore intersection algorithm
            vec3 vertex0 = (models[m].modelMatrix * models[m].vertexData[i]).xyz;
            vec3 vertex1 = (models[m].modelMatrix * models[m].vertexData[i + 1]).xyz;
            vec3 vertex2 = (models[m].modelMatrix * models[m].vertexData[i + 2]).xyz;

            //vec3 vertex0 = models[m].vertexData[i].xyz;
            //vec3 vertex1 = models[m].vertexData[i + 1].xyz;
            //vec3 vertex2 = models[m].vertexData[i + 2].xyz;

            vec3 edge1 = vertex1 - vertex0;
            vec3 edge2 = vertex2 - vertex0;

            vec3 pvec = cross(rayDir, edge2);

            float det = dot(edge1, pvec);
            float epsilon = 0.0000001f;

            if (det < epsilon) {
                continue;
            }

            float invDet = 1.0f / det;

            vec3 tvec = origin - vertex0;

            float x = dot(tvec, pvec) * invDet;
            if (x < 0.0f || x > 1.0f) {
                continue;
            }

            vec3 qvec = cross(tvec, edge1);
            float y = dot(rayDir, qvec) * invDet;
            if (y < 0.0f || x + y > 1.0f) {
                continue;
            }

            float z = dot(edge2, qvec) * invDet;

            vec3 intersect = vertex0 + edge2 * x + edge1 * y;
            vec3 norm = cross(edge1, edge2);
            norm = normalize(norm);
            norm = norm * 0.00001f;
            intersect = intersect + norm;

            if (z < epsilon) {
                continue;
            }

            if (distance(intersect, origin) < dst) {
                dst = distance(intersect, origin);
                vec3 tris[3];
                tris[0] = vertex0;
                tris[1] = vertex1;
                tris[2] = vertex2;
                closestIntersect = IntersectionData(true, intersect, tris);
            }
        }
    }
    return closestIntersect;
}